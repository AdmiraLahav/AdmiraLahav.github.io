<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cyber Terminal</title>
  <style>
    :root {
      --panel-bg: rgba(0, 16, 64, 0.65); /* semi-transparent dark blue */
      --panel-fg: #00ccff;
      --panel-border: #00ccff;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Liberation Mono", monospace;
    }

    /* Matrix canvas underlay */
    canvas#matrix {
      display: block;
      position: fixed;
      inset: 0;
      z-index: 0;
    }

    /* Generic panel */
    .textbox {
      position: absolute;
      display: inline-block;
      color: var(--panel-fg);
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 8px;
      padding: 12px 16px;
      box-sizing: border-box;
      /* Keep long words sane but preserve newlines */
      white-space: pre-wrap;      /* render \n */
      word-break: break-word;     /* break very long tokens */
      line-height: 1.35;
      z-index: 10;
      /* subtle glow */
      box-shadow: 0 0 12px rgba(0, 128, 255, 0.25);
      backdrop-filter: blur(1px);
      -webkit-backdrop-filter: blur(1px);
    }

    /* Optional: handles for visual positioning reference (remove if you want) */
    .textbox::before {
      content: attr(data-title);
      display: block;
      font-size: 12px;
      opacity: 0.7;
      margin-bottom: 4px;
      letter-spacing: 0.04em;
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>

  <!--
    STATIC TEXT you edit in GitHub lives right here.
    You can add more .textbox elements anywhere; JS will size them.
    Control bounds via data-min-width / data-max-width (px).
  -->
  <div
    class="textbox"
    data-title="SYSTEM: MOTD"
    data-min-width="220"
    data-max-width="520"
    style="top: 48px; left: 48px;"
  >Welcome to the Cyber Terminal.
Type is written in the HTML file, not by the user.
Panel expands to fit content (width + height) up to its max.</div>

  <div
    class="textbox"
    data-title="NOTES"
    data-min-width="220"
    data-max-width="640"
    style="top: 220px; left: 48px;"
  >Tip: change data-max-width to control wrapping.
Very long tokens_without_spaces_will_still_break_with_word-break.</div>

  <script>
    /* =========================
       Matrix Rain (your code)
       ========================= */
    const canvas = document.getElementById("matrix");
    const ctx = canvas.getContext("2d");
    function sizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    sizeCanvas();

    const letters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const fontSize = 18;
    let columns = Math.floor(canvas.width / fontSize);
    let drops = Array(columns).fill(1);

    function draw() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#0080ff";
      ctx.font = fontSize + "px monospace";

      for (let i = 0; i < drops.length; i++) {
        const text = letters[Math.floor(Math.random() * letters.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
    }
    const rain = setInterval(draw, 33);

    /* ============================================
       Panel Auto-Size (width + height) Algorithm
       ============================================

       Strategy:
       - Temporarily disable wrapping (white-space: 'pre') to measure the
         panel's *natural* single-line width (scrollWidth).
       - Clamp that width between data-min-width and data-max-width.
       - Restore wrapping (pre-wrap) so height grows naturally.
       - Height is left to the browser (content-driven).
       - Recompute on load + window resize.
       - Optional: observe content changes (MutationObserver).

       Works with any number of elements having class="textbox".
    */

    // Utilities
    function getNumericStyle(el, prop) {
      const cs = getComputedStyle(el);
      const v = cs.getPropertyValue(prop);
      const n = parseFloat(v || "0");
      return Number.isFinite(n) ? n : 0;
    }

    function horizontalExtras(el) {
      // padding-left/right + border-left/right
      return (
        getNumericStyle(el, "padding-left") +
        getNumericStyle(el, "padding-right") +
        getNumericStyle(el, "border-left-width") +
        getNumericStyle(el, "border-right-width")
      );
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function resizeBox(el) {
      const minW = parseInt(el.dataset.minWidth || "200", 10);
      const maxViewport = Math.max(120, window.innerWidth - 96); // keep some margin
      const maxW = Math.min(
        parseInt(el.dataset.maxWidth || "600", 10),
        maxViewport
      );

      // Save current white-space and width to restore
      const prevWS = el.style.whiteSpace;
      const prevW  = el.style.width;

      // Measure ideal single-line width
      el.style.whiteSpace = "pre";  // no wrapping, respect \n
      el.style.width = "auto";      // let it grow
      // Use scrollWidth (content width) + horizontal extras
      const extras = horizontalExtras(el);
      // For multi-line content, scrollWidth returns widest line in 'pre' mode
      let ideal = el.scrollWidth + 0.5; // +epsilon to reduce reflow jitter

      // Clamp width to configured min/max and viewport
      const target = clamp(ideal, minW, maxW);

      // Apply final layout
      el.style.whiteSpace = "pre-wrap"; // back to wrapping mode
      el.style.width = target + "px";

      // Height auto by content; ensure it reflows
      // Force reflow read (optional):
      // void el.offsetHeight;

      // Restore not needed; we want new width & pre-wrap mode to persist
    }

    function resizeAll() {
      document.querySelectorAll(".textbox").forEach(resizeBox);
    }

    // Initial sizing after fonts/layout settle
    window.addEventListener("load", resizeAll);
    window.addEventListener("resize", () => {
      sizeCanvas();
      columns = Math.floor(canvas.width / fontSize);
      drops = Array(columns).fill(1);
      resizeAll();
    });

    // Optional: auto-resize if content changes dynamically later
    const obs = new MutationObserver(() => resizeAll());
    document.querySelectorAll(".textbox").forEach(el => {
      obs.observe(el, { childList: true, characterData: true, subtree: true });
    });
  </script>
</body>
</html>